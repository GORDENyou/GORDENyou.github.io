---
title: "重识Fragment"
date: 2017-07-20
tags: ["Android"]
categories: ["技术之美"]
summary: "以前就已经接触过好几次Fragment了，但是脑海中的Fragment妹子还是“犹抱琵琶半遮面”的样子，现在让我好好的看看她~"
draft: false
---



- Fragment的生命周期
- 静态和动态使用Fragment
- Fragment回退栈
- Fragment事务
- 没有布局的Fragment有何用处？Fragment如何与Activity交互？Fragment如何创建对话框?Fragment如何与ActionBar集成？

## 1.Fragment的生命周期

Fragment必须是依存于Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期。偷一张官网的图说明他们俩的关系：

![](http://oqyqrqoa4.bkt.clouddn.com/Fragment和Activity的关系.png)

| **onAttach(Activity)**                             | 当Fragment与Activity发生关联时调用。                   |
| -------------------------------------------------- | ------------------------------------------------------ |
| **onCreateView(LayoutInflater, ViewGroup,Bundle)** | 创建该Fragment的视图                                   |
| **onActivityCreated(Bundle)**                      | 当Activity的onCreate方法返回时调用                     |
| **onDestoryView()**                                | 与onCreateView想对应，当该Fragment的视图被移除时调用   |
| **onDetach()**                                     | 与onAttach相对应，当Fragment与Activity关联被取消时调用 |

**注意**：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现。

## 2.静态使用Fragment

等候多时的使用时刻来了~

这是使用Fragment的最简单的一种方式，吧Fragment当成普通的控件，直接在Activity的布局文件中调用：

写好Fragment：

```java
public class ContentFragment extends Fragment  
{  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)  
    {  
        return inflater.inflate(R.layout.fragment_content, container, false);  //直接在xml文件调用
    }  
}  
```

在xml中调用：

```xml
<fragment  
        android:layout_below="@id/id_fragment_title"  
        android:id="@+id/id_fragment_content"  
        android:name="com.zhy.zhy_fragments.ContentFragment"  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent" />  
```

即可。

## 3.动态使用Fragment

下面可以动态的添加、更新以及删除Fragment：

```java
public class MainActivity extends Activity implements OnClickListener  
{  
    private LinearLayout mTabWeixin;  
    private LinearLayout mTabFriend;  
  
    private ContentFragment mWeixin;  
    private FriendFragment mFriend;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        // 初始化控件和声明事件  
        mTabWeixin = (LinearLayout) findViewById(R.id.tab_bottom_weixin);  
        mTabFriend = (LinearLayout) findViewById(R.id.tab_bottom_friend);  
        mTabWeixin.setOnClickListener(this);  
        mTabFriend.setOnClickListener(this);  
  
        // 设置默认的Fragment  
        setDefaultFragment();  
    }  
  
    private void setDefaultFragment()  
    {  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction transaction = fm.beginTransaction();  
        mWeixin = new ContentFragment();  
        transaction.replace(R.id.id_content, mWeixin);  
        transaction.commit();  
    }  
  
    @Override  
    public void onClick(View v)  
    {  
        FragmentManager fm = getFragmentManager();  
        // 开启Fragment事务  
        FragmentTransaction transaction = fm.beginTransaction();  
  
        switch (v.getId())  
        {  
        case R.id.tab_bottom_weixin:  
            if (mWeixin == null)  
            {  
                mWeixin = new ContentFragment();  
            }  
            // 使用当前Fragment的布局替代id_content的控件  
            transaction.replace(R.id.id_content, mWeixin);  
            break;  
        case R.id.tab_bottom_friend:  
            if (mFriend == null)  
            {  
                mFriend = new FriendFragment();  
            }  
            transaction.replace(R.id.id_content, mFriend);  
            break;  
        }  
        // transaction.addToBackStack();  
        // 事务提交  
        transaction.commit();  
    }  
  
}  
```

我们使用Fragment事务即可实现动态加载Fragment。

## 4.Fragment家族常用的API

Fragment常用的三个类：

1. android.app.Fragment 主要用于定义Fragment
2. android.app.FragmentManager 主要用于在Activity中操作Fragment
3. android.app.FragmentTransaction 保证一些列Fragment操作的原子性，熟悉事务这个词，一定能明白~

### **a、获取FragmentManage的方式：**

getFragmentManager() // v4中，getSupportFragmentManager

### **b、主要的操作都是FragmentTransaction的方法**

FragmentTransaction transaction = fm.benginTransatcion();//开启一个事务

1. **transaction.add()**

   往Activity中添加一个Fragment

2. **transaction.remove()**

   从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈后面会详细说），这个Fragment实例将会被销毁。

3. **transaction.replace()**

   使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体~

4. **transaction.hide()**

   隐藏当前的Fragment，仅仅是设为不可见，并不会销毁

5. **transaction.show()**

   显示之前隐藏的Fragment

6. **detach()**

   会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护。

7. **attach()**

   重建view视图，附加到UI上并显示。

8. transatcion.commit()//提交一个事务

注意：常用Fragment的哥们，可能会经常遇到这样Activity状态不一致：State loss这样的错误。主要是因为：commit方法一定要在Activity.onSaveInstance()之前调用。

上述，基本是操作Fragment的所有的方式了，在一个事务开启到提交可以进行多个的添加、移除、替换等操作。

值得注意的是：如果你喜欢使用Fragment，一定要清楚这些方法，哪个会销毁视图，哪个会销毁实例，哪个仅仅只是隐藏，这样才能更好的使用它们。

**a、比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。**

**b、再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。**

**c、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。**

## 5.管理Fragment回退栈

类似于为Activity的维护设置一个任务栈，我们也可以通过Activity维护一个回退栈来保存每次Fragment事务发生的变化。如果你将Fragment任务添加回到回退栈，当用户点击回退按钮后，将看到上次保存的Fragment。一旦Fragment完全从后退栈中弹出，当用户再次点击后退键时，则退回当前Activity。

如何添加一个Fragment事务到回退栈：

```java
FragmentTransaction.addToBackStack(String);
```



## 6.Fragment与Activity的通信

由于所有的Fragment都是依附于Activity的，所以通信起来并不复杂：

1. 如果你Activity中包含管理自己的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法；
2. 如果Activity中未保存任何Fragment的引用，也没有关系，每个Fragment都有一个唯一的TAG或者ID，可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。
3. 在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作。

注意：如果在Fragment中需要Context，可以通过调用getActivity()，如果该Context需要在Activity被销毁之后依然存在，则使用getActivity().getApplicationContext().

## 7.Fragment与Activity通信的最佳实践