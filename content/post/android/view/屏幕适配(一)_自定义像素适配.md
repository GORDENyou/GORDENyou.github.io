---
title: "屏幕适配——自定义像素适配"
author: "Gordenyou"
date: 2019-03-08T15:53:45+08:00
categories: ["技术之美"]
tags: ["Android", "屏幕适配"]
lastmod: 
draft: false
summary: "屏幕的适配有多种方法，我们先来看看如何进行自定义像素适配。" 
---

 

作为屏幕适配的开篇，我们先来看看屏幕适配常见方式：

- 布局适配：
  1. 避免写死空间尺寸，使用`wrap_content, match_parent` 等。
  2. `LinearLayout :layout_weight = "0.5"`
  3. `RelativeLayout : layout_centerInParent = "true"`
  4. `ContraintLayout : layout_constraintLeft_toLeftOf = "parent"`
  5. 使用百分比布局容器：`Percent-support-lit : layout_widthPercent = "30%"`

- 图片资源适配：
  1. 使用.9图或者SVG图实现缩放。SVG图片缩放不失真，而且体积小。
  2. 备用位图匹配不同的分辨率。
- 用户流程适配：
  1. 根据业务逻辑执行不同的跳转逻辑
  2. 根据别名展示不同的界面
- 限定符适配：
  1. 分辨率限定符：`drawable_hdpi, drawable_xdpi...` ，对应了上面的备用位图匹配。
  2. 尺寸限定符：`layout-small, layout-larget, ...`
  3. 最小宽度限定符： `values-sw360dp, values-sw384dp, ...` `sw`表示最小宽度
  4. 屏幕方向限定符： `layout-land 水平, layout-port 竖直`
- 刘海屏适配：
  1. `Android 9.0` 官方适配。
  2. 华为，`Oppo`， `Vivo` 需要参考其官方文档。

接下来进入本文主题：自定义像素适配。



## 实现原理

如何实现像素适配？

我们可以先以一套特定的像素的设备作为参考（比如最常见的屏幕尺寸），然后对其他类型屏幕做适配即可。我们需要在View加载的过程中，根据当前设备的实际像素换算出目标像素，然后再绘制控件。

## 创建工具类

我们可以创建一个工具类，专门用于获取适配像素：

```java
public class Utils {

    private static Utils utils;

    //参考设备宽高，最常用的宽高
    private static final float STANDARD_WIDTH = 1080;
    private static final float STANDARD_HEIGHT = 1920;

    //当前屏幕显示宽高
    private int mDisplayWidth;
    private int mDisplayHeight;

    private Utils(Context context){
        //获取屏幕的宽高
        if(mDisplayWidth == 0 || mDisplayHeight == 0){
            WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
            if (manager != null){
                DisplayMetrics displayMetrics = new DisplayMetrics();
                manager.getDefaultDisplay().getMetrics(displayMetrics);
                //横竖屏不同情况
                if (displayMetrics.widthPixels > displayMetrics.heightPixels){
                    //横屏
                    mDisplayWidth = displayMetrics.heightPixels;
                    mDisplayHeight = displayMetrics.widthPixels;
                }else{
                    mDisplayWidth = displayMetrics.widthPixels;
                    mDisplayHeight = displayMetrics.heightPixels - getStatusBarHeight(context);
                }
            }
        }

    }

    
    //获取状态栏高度
    public int getStatusBarHeight(Context context){
        //获取状态栏对应资源ID
        int resID = context.getResources().getIdentifier("status_bar_height", "dimen", "android");
        if (resID > 0){
            return context.getResources().getDimensionPixelSize(resID);
        }
        return 0;
    }

    public static Utils getInstance(Context context){
        if (utils == null){
            utils = new Utils(context.getApplicationContext());
        }
        return utils;
    }

    //获取水平方向的缩放比例
    public float getHorizontalScale(){
        return mDisplayWidth / STANDARD_WIDTH;
    }

    //获取垂直方向的缩放比例
    public float getVerticalScale(){
        return mDisplayHeight / STANDARD_HEIGHT;
    }

}
```

## 自定义ViewGroup

在`View`显示的过程中，`onMeasure()`方法确定了`View`的宽高，因此我们需要重写此方法：

```java
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (!flag){
            float scaleX = Utils.getInstance(getContext()).getHorizontalScale();
            float scaleY = Utils.getInstance(getContext()).getVerticalScale();

            int count = getChildCount();
            //遍历子控件，对子控件进行缩放
            for (int i = 0; i < count; i++) {
                View child = getChildAt(i);
                LayoutParams params = (LayoutParams) child.getLayoutParams();
                params.width = (int) (params.width * scaleX);
                params.height = (int) (params.height * scaleY);
                params.leftMargin = (int)(params.leftMargin * scaleX);
                params.rightMargin = (int)(params.rightMargin * scaleX);
                params.topMargin = (int)(params.topMargin * scaleY);
                params.bottomMargin = (int)(params.bottomMargin * scaleY);
            }
            //防止过度绘制
            flag = true;
        }
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
```

在这里我重写了一个`RelativeLayout` 的 `onMeasure()`方法，若是重写一个`View`的`onMeasur()`方法则不需要遍历其子`View`。

**这里有一个需要注意的地方，我们在`xml`布局文件中使用`px`，而不能使用`dp`**：

```java
android:layout_width="360px"
android:layout_height="360px"
```

## 实现效果

我们将测试类的宽高设置为参考设备宽高的一半：

```java
android:layout_width="540px"
android:layout_height="960px"
```

这样我们在不同设备上显示的控件的宽高都为当前设备像素的一半。

`1080*1920`显示效果：

![](../picture/dp_1920.png)

1440*2560`显示效果：

![](../picture/dp_1440.png)

可以看出，虽然分辨率不同，但是显示的比例是相同的。