---
title: "单例及其应用"
author: "Gordenyou"
date: 2019-03-01T19:17:25+08:00
categories: ["技术之美"]
tags: ["设计模式"]
lastmod: 
draft: false
summary: "单例可能是我们尔等初级工程师唯一会用的创建模式（手动狗头）。这次我们来看看单例在Android源码中的应用"
---

- 单例模式的几种形式及其优缺点
- 单例模式在安卓中的应用

## 单例模式的几种形式及其优缺点

单例的应用场景主要是某个类只能有一个实例的场景，避免产生多个对象消耗过多的资源。例如：访问IO、访问数据库资源等操作。

UML：

![](../picture/Singleton.png)

#### 饿汉模式

之所以叫饿汉模式，是因为Java虚拟机在加载此类的时候就已经将其实例创建了。

```java
public class Singleton{
	private static fianle Singleton instance = new Singleton();
	
	private Singleton(){}
	
	private static getInstance(){
		return instance;
	}
}
```



#### 饿汉模式

```java
public class Singleton{
	private static Singleton instance;
	private Singleton(){}
	
	public static synchronized Singleton getInstance(){
		if(instance == null){
			instance = new Singleton();
		}
		return instance;
	}
}
```

虽然我们使用了`synchronized`关键字保证了线程安全，但是我们每次获取时同时也**浪费了大量时间**，影响了性能。这是饿汉模式的最大的问题。



#### Double Check Lock(DCL)模式

```java
public calss Singleton{
	private static Singleton instance = null;
	private Singleton(){}
	
	public static Singleton getInstance(){
		if(instance == null){
			synchronized(Singleton.class){
				if(instance == null){
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

这里最美妙的地方就是双次检验：

- 第一次检验是为了避免不必要的同步（没有实例化的时候才需要同步），所以只有第一次创建时会慢一点，后面获取时会很快捷。
- 第二次检验是判断在进入同步之前是否创建。因为在多进程的情景下，代码在不同进程下执行有先后次序，会存在A进程第一次判断时`instance`还没有进行实例化，但是此时切换到了另外一个B进程，完成实例化并返回A进程继续运行，和之前A判断的结果就有出入了，所以我们进入了同步代码块中需要再检测一次。

总结一下：DCL的资源利用率高，第一次执行`getInstance()`单例对象才会实例化，效率高。但是由于 Java 内存模型的原因，有失败的情况，所以需要谨慎使用。



#### 静态内部类单例模式

这是目前为止最好的一种方式了

```java
public class Singleton{
	private Singleton(){}
	
	public static Singletong getInstance(){
		return SingletonHolder.instance;
	}
	
	/**
	* 静态内部类
	*/
	private static class SingletonHolder{
		private static final Singleton instance = new Singleton();
	}
}
```

当我们第一次加载`Singleton`类的时候并不会初始化`instance`，只有我们在第一次调用`getInstance()`方法时，才会导致`instance`的初始化。

关于内部类的[详解](https://blog.csdn.net/jeffleo/article/details/52210336)。

这种方式不仅能保证线程安全，也能保证单例对象的唯一性，同时延迟了单例的初始化。



#### 枚举模式

有了上面这么优秀的实现模式，为什么还会出现枚举的实现模式？

应为有的场景需要将单例序列化，然而在反序列化的过程中我们为了防止再一次创建一个实例，我们需要加入`readResolve()`函数：

```java
public final class Singleton implements Serializable{
	private static final log serialVersionUID = 0L;
	private static final Singleton INSTANCE = new Singleton();
	
	private Singleton(){}
	
	public static Singleton getInstance(){
		return INSTANCE;
	}
	
	private Object readResolve() throws ObjectStreanException{
		return INSTANCE;
	}
}
```

然而枚举并不存在这个问题。



#### 使用容器

```java
public class SingletonManager{
	private static Map<Stirng, Object> objMap = new HashMap<Stirng, Object>();
	
	private SingletonManager(){}
	
	public static void registerService(String key, Object instance){
		if(!objMap.containsKey(key)){
			objMap.put(key, instance);
		}
	}
	
	public static Object getService(String key){
		return objMap.get(key);
	}
}
```

这种方式可以方便我们管理多个单例实例，并且通过统一的接口进行获取操作。